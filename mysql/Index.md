## Index (인덱스)

칼럼(또는 칼럼들)의 값과 해당 레코드가저장된 주소를 키와 값의 쌍(key-Value pair)을 키(칼럼의 값)순으로 정렬하여 테이블의 검색속도를 향상시킨다.

데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고, 데이터의 읽기 속도를 높이는 기능

-> 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하는지의 여부에 따라 결정돼야 함



#### SortList VS ArrayList

* SortList
  * 저장되는 값을 항상 정렬된 상태로 유지하는 자료구조
  * DBMS의 인덱스는 SortList와 마찬가지로 저장되는 칼럼의 값을 이용해 항상 정렬된 상태로 유지
  * INSERT, UPDATE, DELETE 속도는 느리지만 SELECT는 빠름
* ArrayList
  * 저장되는 값을 저장되는순서대로 그대로 유지하는 자료구조
  * 데이터파일은 ArrayList와 마찬가지로 저장된 순서대로 별도의 정렬 없이 그대로 저장



#### 인덱스의 분류 : 역할별 분류

* Primary Key (프라이머리 키 또는 식별자)
  * 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스
  * NULL값과 중복을 허용하지 않음 
* Seocondary Key (보조 키)
  * 프라이머리 키를 제외한 나머지 모든 인덱스

> 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용할 수도 있다고 해서 대체 키라고도 하는데, 별도로 분류하기도 하고 그냥 보조 인덱스로 분류하기도 한다.



#### 인덱스의 분류 : 데이터 저장 방식(알고리즘)별 분류

* B-Tree 인덱스
  * 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱
* Hash 인덱스
  * 칼럼의 값으로 해시 값을 계산해서 인덱싱
  * 매우 빠른 검색을 지원
  * 값을 변형해서 인덱싱하므로, 전형(Prefix) 일치와 같이 값의 일부만 검색하고자 할 때는 사용 불가
  * 메모리 기반의 데이터베이스에서 많이 사용
* Fractal-Tree 인덱스
  * B-Tree의 단점을 보완하기 위해 고안됨
  * 값을 변형하지 않고 인덱싱 하여 범용적인 목적으로 사용 가능 (B-Tree와 공통점)
  * 데이터가 젖아되거나 삭제될 때 처리비용을 상당히 줄일 수 있도록 설계됨
  * 아직 B-Tree 알고리즘만큼 안정적이고 성숙되진 않았지만 B-Tree 인덱스의 상당 부분을 대체할 수 있을것이라고 예측



#### 인덱스의 분류 : 중복 허용 여부별 분류

* Unique 인덱스
  * 같은 값이 1개만 존재하는 칼럼(또는 칼럼의 집합)에 대한 인덱스
  * 동등조건 (Equal, =)으로 검색한다는 것은 항상 1건의 레코듬나 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 것
* Non-Unique 인덱스
  * 같은 값이 1개 이상 존재할 수 있는 칼럼(또는 칼럼의집합)에 대한 인덱스



#### 인덱스의 분류 : 기능별 분류

* 전문 검색용 인덱스
* 공간 검색용 인덱스







#### 참고자료

개발자와 DBA를 위한 Real MySQL, 저 이성욱